#include "auxiliary_algorithms.h"

/// <summary>
/// Итеративная версия бинарного поиска.
/// </summary>
/// <param name="v">Отсортированный вектор строк, в котором ведётся поиск</param>
/// <param name="l">Индекс левой границы поиска</param>
/// <param name="r">Индекс правой границы поиска</param>
/// <param name="target">Цель поиска</param>
/// <returns>Индекс найденной строки в векторе v, иначе возвращает -1.</returns>
int binarySearch(std::vector<std::string>& v, int l, int r, std::string target)
{
    while (l <= r) {
        // нахождение середины рассматриваемого подмассива
        int m = l + (r - l) / 2;

        // проверка середины подмассива на равенство цели
        if (v[m] == target)
            return m;

        // Если цель больше середины подмассива, то на следующей итерации
        // начинаем рассматривать правый подмассив.
        if (v[m] < target)
            l = m + 1;
        // Иначе начинаем рассматривать левый подмассив.
        else
            r = m - 1;
    }

    // возвращаем -1, если искомый элемент отсутствует в массиве
    return -1;
}

/// <summary>
/// Функция для обмена содержимым двух строк по их переданным указателям.
/// </summary>
/// <param name="a">Указатель строки a</param>
/// <param name="b">Указатель строки b</param>
void swap(std::string* a, std::string* b)
{
	std::string temp = *a;
	*a = *b;
	*b = temp;
}

/// <summary>
/// Функция для нахождения верной позиции для опорного элемента. Слева и
/// справа от него формируются подмассив меньших и больших элементов соответственно.
/// </summary>
/// <param name="v">Вектор строк</param>
/// <param name="l">Индекс начального элемента (low)</param>
/// <param name="h">Индекс последнего элемента (high)</param>
/// <returns></returns>
int partition(std::vector<std::string>& v, int l, int h)
{
	// В качестве опорного элемента выступает самый правый элемент
	std::string pivot = v.at(h);

	// Переменная i хранит в себе правильную позицию опорного элемента
	// после сортировки. Она инкрементируется, если был встречен элемент,
	// который меньше опорного. Таким образом, этот счётчик покажет в конце верную позицию.
	int i = (l - 1);

	for (int j = l; j <= h - 1; j++)
	{
		if (v.at(j) <= pivot)
		{
			++i;
			swap(&v.at(i), &v.at(j));
		}
	}

	// Обмен местами между i + 1 элементом и опорным элементом. После чего
	// опорный элемент встаёт на правильную с точки зрения сортировки позицию.
	swap(&v.at(i + 1), &v.at(h));
	return (i + 1);
}

/// <summary>
/// Быстрая сортировка вектора строк в итеративном варианте.
/// </summary>
/// <param name="v">Вектор строк</param>
/// <param name="l">Индекс начального элемента (low)</param>
/// <param name="h">Индекс последнего элемента (high)</param>
void quickSortIterative(std::vector<std::string>& v, int l, int h)
{
	// Вспомогательный стэк, который хранит значения l и h для подмассивов.
	int* stack = new int[h - l + 1];

	// Переменная для индексации вершины стэка
	int top = -1;

	// Добавление начальных l и h на вершину стэка
	stack[++top] = l;
	stack[++top] = h;

	// Обрабатываем стэк аргументов, пока он не опустеет. Стэк наполняется
	// в случае, если ещё есть необработанный подмассив.
	while (top >= 0)
	{
		// Взятие из вершины стэка очередных аргументов h и l для нового разбиения
		h = stack[top--];
		l = stack[top--];

		// Установка опорного элемента в правильную позицию, формирование подмассивов
		// вокруг него.
		int p = partition(v, l, h);

		// Заносим левый подмассив в стэк, если в нём есть элементы
		if (p - 1 > l)
		{
			stack[++top] = l;
			stack[++top] = p - 1;
		}

		// Заносим правый подмассив в стэк, если в нём есть элементы
		if (p + 1 < h)
		{
			stack[++top] = p + 1;
			stack[++top] = h;
		}
	}

	delete[] stack;
}